# 策略模式 #

## 参考 ##
<https://blog.csdn.net/liang19890820/article/details/79242297>

## 简述 ##
策略模式（Strategy Pattern）定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换。Strategy 可以使算法独立于使用算法的客户端  
策略模式使用的就是面向对象的继承和多态的机制。

## 模式结构 ##
UML结构图  
![策略模式](../UML/Strategy.png "Strategy Pattern")  

- Context（环境角色）：持有一个对 Strategy 的引用，最终给客户端调用。  
- Strategy（抽象策略）：定义了一个公共接口，让不同的算法以不同的方式来实现。通过这个接口，Context 可以调用不同的算法。  
- ConcreteStrategy（具体策略）：实现 Strategy 定义的接口，提供具体算法的实现。  

这里的关键就是将算法的逻辑抽象接口(ContextInterface)封装到一个类中（Context）,再通过委托的方式将具体的算法实现委托给具体的Strategy类来实现（ConcreteStrategyA类）

## 优缺点 ##

优点：  

- 扩展性良好  
	各自使用封装的算法，可以很容易地引入新的算法来满足相同的接口。  
- 算法可以自由切换  
	由于实现的是同一个接口，所以策略之间可以自由切换。  
- 避免使用多重条件判断  
	Strategy 使客户端能够选择所需的算法，而无需使用 switch/case 或 if/else 语句。  
- 算法的细节完全封装在 Strategy 类中，因此，可以在不影响 Context 类的情况下更改算法的实现。  

缺点：  

- 客户端必须知道所有的策略，了解它们之间的区别，以便适时选择恰当的算法。  
- 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。  

## 适用场景 ##

- 多个类有不同的表现形式，每种表现形式可以独立成单独的算法。  
- 需要在不同情况下使用不同的算法，以后算法可能还会增加。  
- 对客户端隐藏具体算法的实现细节，彼此完全独立。  

## 注意事项 ##
如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题。

## 总结 ##

1. 在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。  
2. 